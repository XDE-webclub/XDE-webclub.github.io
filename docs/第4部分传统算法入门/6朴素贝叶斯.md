
## 朴素贝叶斯

这个算法是建立在贝叶斯理论上的分类方法。

它的假设条件是自变量之间相互独立。

简言之，朴素贝叶斯假定某一特征的出现与其它特征无关。

比如说，如果一个水果它是红色的，圆状的，直径大概7cm左右，我们可能猜测它为苹果。即使这些特征之间存在一定关系，在朴素贝叶斯算法中我们都认为红色，圆状和直径在判断一个水果是苹果的可能性上是相互独立的。

虽然模型简单，但很多情况下工作得比非常复杂的分类方法还要好。



```python 
from sklearn.naive_bayes import GaussianNB
import numpy as np

# 创建一些示例数据
X = np.array([[1], [2], [3], [4], [5]])  # 特征
y = np.array([0, 0, 1, 1, 1])  # 目标标签

# 创建朴素贝叶斯分类器 (高斯朴素贝叶斯)
model = GaussianNB()

# 拟合模型
model.fit(X, y)

# 预测新数据点
new_data_point = np.array([[6]])  # 要预测的新数据点
predicted_class = model.predict(new_data_point)
predicted_proba = model.predict_proba(new_data_point)

print("预测类别:", predicted_class)
print("类别概率:", predicted_proba)

```


### 简单示例


```python 
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
import sklearn.datasets

data = sklearn.datasets.load_iris()
X = data.data
y = data.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)


model = GaussianNB()
# 拟合模型
model.fit(X_train, y_train)

```


### 效果评估


```python 

from sklearn.metrics import accuracy_score  

# 计算准确率  
accuracy = accuracy_score(y_test, model.predict(X_test))  
accuracy
```


### 查看分类错误的样本信息


```python 
import pandas as pd

# 把测试数据、目标标签、预测结果合并到一起
df = pd.concat(
    [pd.DataFrame(X_test,columns=data.feature_names), 
     pd.DataFrame(y_test,columns=['target']),
     pd.DataFrame(model.predict(X_test),columns=['predict'])
     ],axis=1 )

# 筛选target列与predict列不相等的数据
df.loc[df['target']!=df['predict']]

```

