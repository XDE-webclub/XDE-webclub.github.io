

## 面向对象编程


面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。


### 类（Class）和实例（Instance）
面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，张三和李四是两个具体的Student。

所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。

面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。


### 创建类

#### 类的特殊方法
Python 使用 __ 开头的名字来定义特殊的方法和属性，它们有：
```
__init__()
__repr__()
__str__()
__call__()
__iter__()
__add__()
__sub__()
__mul__()
__rmul__()
__class__
__name__
```
构造方法 `__init__()`

在产生对象之后，我们可以向对象中添加属性。
事实上，还可以通过构造方法，在构造对象的时候直接添加属性：


```python 
class Clothes(object):
    """
    init_demo
    """

    def __init__(self, color="green"):
        self.color = color


my_clothes = Clothes()
my_clothes.color
```


传入有参数的值：


```python 
your_clothes = Clothes('orange')
your_clothes.color
```


表示方法 `__repr__() 和 __str__()`:


```python 
class Clothes(object):
    """
    repr and str demo
    """

    def __init__(self, color="green"):
        self.color = color

    def __str__(self):
        "This is a string to print."
        return ("a {} clothes".format(self.color))

    def __repr__(self):
        "This string recreates the object."
        return ("{}(color='{}')".format(self.__class__.__name__, self.color))
```


`__str__()` 是使用 print 函数显示的结果,类似java中的toString：


```python 
my_clothes = Clothes()
print(my_clothes)
```


`__repr__()` 返回的是不使用 print 方法的结果:


```python 
my_clothes
```


```python 
print(my_clothes.__class__, my_clothes.__class__.__name__, my_clothes.color)
```


```python 
my_clothes.__class__, my_clothes.__class__.__name__, my_clothes.color
```


#### 类的属性
只读属性：


```python 
class Clothes(object):
    def __init__(self, price):
        self.price = price

    # 这样 discount_price 就变成属性了
    @property
    def discount_price(self):
        return self.price * 0.8
```


这里 discount_price 就是一个只读不写的属性了（注意是属性不是方法）,
而price是可读写的属性：


```python 
my_clothes = Clothes(100)
print(my_clothes.discount_price)  # 80.0
```


可以修改price属性来改变discount_price：



```python 
my_clothes.price = 200
print(my_clothes.discount_price)  # 160.0
```


my_clothes.discount_price()会报错，因为 my_clothes.discount_price 是属性，不是方法；

my_clothes.discount_price=100 也会报错，因为只读。


对于 @property 生成的只读属性，我们可以使用相应的 @attr.setter 修饰符来使得这个属性变成可写的：


```python 
class Clothes(object):
    def __init__(self, price):
        self.price = price

    # 这样就变成属性了
    @property
    def discount_price(self):
        return self.price * 0.8

    @discount_price.setter
    def discount_price(self, new_price):
        self.price = new_price * 1.25
```


测试一下：


```python 
my_clothes = Clothes(100)
print(my_clothes.discount_price)

my_clothes.price = 200
print(my_clothes.discount_price)
```


修改 discount_price 属性：


```python 
my_clothes.discount_price = 180
print(my_clothes.price)
print(my_clothes.discount_price)
```


一个等价的替代如下，用方法：


```python 
class Clothes(object):
    def __init__(self, price):
        self.price = price

    def get_discount_price(self):
        return self.price * 0.8

    def set_discount_price(self, new_price):
        self.price = new_price * 1.25

    discount_price = property(get_discount_price, set_discount_price)

```


```python 
my_clothes = Clothes(100)
print(my_clothes.discount_price)

my_clothes.price = 200
print(my_clothes.discount_price)

my_clothes.discount_price = 180
print(my_clothes.price)
print(my_clothes.discount_price)
```

