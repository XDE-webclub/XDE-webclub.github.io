
## 函数和模块

编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”

### 函数

为了减少重复，函数登场。

#### 定义函数

在Python中可以使用 def 关键字来定义函数，程序中函数的参数就相当于是数学上说的函数的自变量，可以通过 return 关键字来返回一个值，这相当于数学上说的函数的因变量。


```python 
def add(a, b):
    """
    add two nums
    :param a: first num
    :param b: second num
    :return: result
    """
    c = a + b
    return c
```


#### 使用函数

使用函数时，只需要将参数换成特定的值传给函数。


```python 
# Python并没有限定参数的类型，因此可以使用不同的参数类型：
print(add(2, 3))

print(add('foo', 'bar'))  # foobar
```


传入参数时，Python提供了两种选项，

第一种是上面使用的按照位置传入参数，

另一种则是使用关键词模式，显式地指定参数的值：


```python 
add(a=2, b=3)
```


```python 
add(b='morning', a='good')
```


```python 
add(2, b=3)  # 5
```


#### 设定默认参数


```python 
def quad(x, a=1, b=0, c=0):
    return a * x * x + b * x + c
```


```python 
quad(2.0)
```


```python 
quad(2.0, b=3)
```


#### 接收不定参数

使用如下方法，可以使函数接受不定数目的参数,类似java的..多个参数：


```python 
def add(x, *args):
    total = x
    for arg in args:
        total += arg
    return total
```


*args 表示参数数目不定，可以看成一个元组，

把第一个参数后面的参数当作元组中的元素。


```python 
print(add(1, 2, 3, 4, 5))  # 15
print(add(1, 2))  # 3
```


#### 使用关键词传入参数


```python 
def add(x, **kwargs):
    total = x
    for arg, val in kwargs.items():
        print("adding ", arg)
        total += val
    return total
```


**kwargs 表示参数数目不定，相当于一个字典，关键词和值对应于键值对。


```python 
add(1, a=2, b=3)  # 6
```


```python 
# 可以接收任意数目的位置参数和键值对参数：
def fun1(*args, **kwargs):
    print(args, kwargs)
    
fun1(2, 3, a="bar", b=10)  # (2, 3) {'a': u'bar', 'b': 10}
```


#### 返回多个值


```python 
# 函数可以返回多个值：
def to_val(x, y):
    r = (x ** 2 + y ** 2) ** 0.5
    total = x + y
    return r, total
```


```python 
a, b = to_val(3, 4)
print(a, b)  # 5.0 7
```


```python 
# 事实上，Python将返回的两个值变成了元组：
print(to_val(3, 4))  # (5.0, 7)
```


```python 
# 列表也有相似的功能,可以用来赋值：
a, b, c = [1, 2, 3]
print(a, b, c)
```


```python 
# 可以将参数用元组传入：
def add(a, b):
    return a + b

c = (2, 3)
print(add(*c))  # 5
# 这里的*必须要。
```


```python 
# 还可以用字典传入参数哦：
d = {'a': 2, 'b': 5}
print(add(**d))  # 7
```


#### map 方法生成序列
map函数

map() 会根据提供的函数对指定序列做映射。

map(aFun, aSeq)


```python 
def sqr(x):
    return x ** 2
```


```python 
a = [2, 3, 4]
result = map(sqr, a)  # [4,9,16]
type(result)
```


```python 
# map返回的是个迭代器对象, 可以转化为list显示

list(result)
```


事实上，根据函数参数的多少，map 可以接受多组序列，
将其对应的元素作为参数传入函数：



```python 
def add(a, b):
    return a + b

a = [2, 3, 4]
list(map(sqr, a))  # [4,9,16]
```


```python 
a = (2, 3, 4)
b = [10, 11, 15]
list(map(add, a, b))  # [12, 14, 19]
```


#### reduce

reduce() 函数会对参数序列中元素进行累积。


```python 
from functools import reduce

def add(x, y) :            # 两数相加
    return x + y
sum1 = reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5
sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数
print(sum1)
print(sum2)
```


### 模块

用模块管理函数，Python中每个文件就代表了一个模块（module），

Python会将所有 .py 结尾的文件认定为Python代码文件。


在使用函数的时候我们通过import关键字导入指定的模块：

`module1.py`

```python
def foo():
    print('hello, world!')

```

`module2.py`
```python
def foo():
    print('goodbye, world!')
```

`test.py`
```python
from module1 import foo

# 输出hello, world!
foo()

from module2 import foo

# 输出goodbye, world!
foo()
```


#### __name__ 属性
有时候我们想将一个 .py 文件既当作脚本，又能当作模块用，
这个时候可以使用 __name__ 这个属性。


```python
PI = 3.14


def get_sum(lst):
    """
    Sum the values in the list
    :param lst:
    :return:
    """
    total = 0
    for v in lst:
        total = total + v
    return total

```

上文保存为ex.py



```python 
with open('ex.py', 'w') as f:
    f.write("""
PI = 3.14
def get_sum(lst):
    total = 0
    for v in lst:
        total = total + v
    return total
    """)
```


使用 ! 调用shell命令：


```python 
!cat ex.py
```


可以从ex模块中导入函数get_sum和变量：


```python 
from ex import PI, get_sum

print(PI)  # 3.14
print(get_sum([2, 3]))  # 5

# 可以使用 * 导入所有变量, 不提倡，因为可能覆盖一些已有的函数
```


```python 
# 删除文件：
import os

os.remove('ex.py')
```


通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：

> 前目录，即当前执行的程序文件所在目录下查找；

> 到 PYTHONPATH（环境变量）下的每个目录中查找；

> 到 Python 默认的安装目录下查找。

以上所有涉及到的目录，都保存在标准模块 sys 的 sys.path 变量中，通过此变量我们可以看到指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 sys.path 显示的目录中，那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。

解决“Python找不到指定模块”的方法有 3 种，分别是：

> 向 sys.path 中临时添加模块文件存储位置的完整路径；

> 将模块放在 sys.path 变量中已包含的模块加载路径中；

> 设置 path 系统环境变量。


如果持续不断加载数据，调用函数模块，计算机的内存会溢出，Python的垃圾回收机制。是计数机制，当一个对象的引用数为0时，它就会被垃圾回收机制回收。


```python 
import sys
# 生以下四种情况的时候，该对象的引用计数器+1
a= 999 # 对象被创建  
b=a   # 对象被引用 
def func(a):
    return
func(a)   # 对象被作为参数,传到函数中
List=[a,"a","b",2]   # 对象作为一个元素，存储在容器中   
sys.getrefcount(a)
# python系统内部很多地方都在使用一些常用的对象，这些对象在python解释器启动时就被创建出来。

#发生以下四种情况时，该对象的引用计数器**-1**

#该对象的别名被显式销毁时    
del a
#该对象的引别名被赋予新的对象，   
a = 999
#个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
#该元素从容器中删除时，或者容器被销毁时。
b = a  # 当前计数器为2
del b # 删除变量b：b对应的对象的引用计数器-1   （此时计数器为1）
del a # 删除变量a：a对应的对象的引用计数器-1    (此时引用计数器为0)

# 当引用计数器为0 时，意味着没有人再使用这个对象，这个对象就变成垃圾，垃圾回收。
# 回收：1.对象从refchain的链表移除。
#.将对象进行销毁，内存归还给操作系统，可用内存就增加。
sys.getrefcount(a)
```

