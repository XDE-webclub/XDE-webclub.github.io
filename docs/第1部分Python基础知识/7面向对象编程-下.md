
### 继承

类定义的基本形式：
```python
class ClassName(ParentClass):
    """class docstring"""
    def method(self):
        return
```

里面的 ParentClass 就是用来继承的。



```python 
class Clothes(object):
    def __init__(self, color="green"):
        self.color = color

    def out_print(self):
        return self.__class__.__name__, self.color
```


```python 
my_clothes = Clothes()
my_clothes.color
```


```python 
my_clothes.out_print()
```


定义一个子类，继承父类的所有方法:


```python 
class NikeClothes(Clothes):
    def change_color(self):
        if self.color == "green":
            self.color = "red"
```


继承父类的所有方法：


```python 
your_clothes = NikeClothes()
your_clothes.color
```


```python 
your_clothes.out_print()
```


但有自己的方法：


```python 
your_clothes.change_color()
your_clothes.color
```


如果想对父类的方法进行修改，只需要在子类中重定义这个类即可：


```python 
class AdidasClothes(Clothes):
    def change_color(self):
        if self.color == "green":
            self.color = "black"

    def out_print(self):
        self.change_color()
        return self.__class__.__name__, self.color


him_clothes = AdidasClothes()
print(him_clothes.color)

him_clothes.change_color()
print(him_clothes.color)
print(him_clothes.out_print())
```


#### super() 函数
super(CurrentClassName, instance)

返回该类实例对应的父类对象。

刚才 AdidasClothes可以改写为：


```python 
class NewAdidasClothes(Clothes):
    def change_color(self):
        if self.color == "green":
            self.color = "black"

    def out_print(self):
        self.change_color()
        print(super(NewAdidasClothes, self).out_print())

her_clothes = NewAdidasClothes()
print(her_clothes.color)

her_clothes.out_print()
```


#### __new__() 方法

__new__()用来创建一个实例，它至少有一个参数cls，代表当前类。默认情况下__new__()会创建当前类的实例，该方法也可以被重载，重载后也可以创建其他类的实例。


```python 
class Fun(object):
    def __init__(self, fun):
        self.fun = fun
 
    def __new__(cls, *args, **kwargs):
        return object.__new__(Fun)
 
if __name__ == '__main__':
    f = Fun.__new__(Fun)
    print(type(f))
```


__new__()方法只是创建实例，此时拿到的实例并不能正常使用。一个实例需要被__init__()方法初始化后才可以被正常使用。也就是说，正常场景下，我们生成一个类的实例，Python先调用该类的__new()__方法创建一个实例，然后再调用__init__()方法初始化该实例。__new()__方法存在于object方法中，通常情况下不需要被重载。

可以使用__new__方法创建出其它类的实例。在这种场景下，__new__方法创建后会调用对应类的__init__方法完成初始化：


```python 
class Fun(object):
    def __init__(self, fun):
        self.fun = fun
 
    def __new__(cls, *args, **kwargs):
        return Demo(*args, **kwargs)
 
 
class Demo(object):
    def __init__(self, d):
        self.demo = d
 
 
if __name__ == '__main__':
    f = Fun(1)
    print("type f:", type(f))
    print("f.demo:", f.demo)
```


可以看出，f不是Fun类的一个实例，而是Demo类的一个实例，拥有Demo类的字段。因为Fun类的__new__方法创建的是一个Demo类实例，而非Fun类本身。因此Fun.__new__方法在return后调用了Demo.__init__方法，以完成该实例的初始化。


### 接口

接口的调用：


```python 
class Clothes(object):
    def __init__(self, color="green"):
        self.color = color

    def out(self):
        print("father.")


class NikeClothes(Clothes):
    def out(self):
        self.color = "brown"
        super(NikeClothes, self).out()


class AdidasClothes(object):
    def out(self):
        print("adidas.")

```


因为三个类都实现了 out() 方法，因此可以这样使用：


```python 
objects = [Clothes(), NikeClothes(), AdidasClothes()]
for obj in objects:
    obj.out()
```


### 类方法
类方法包括以下几种：
1. special 方法和属性，即以 __ 开头和结尾的方法和属性
2. 私有方法和属性，以 _ 开头，不过不是真正私有，而是可以调用的，
但是不会被代码自动完成所记录（即 Tab 键之后不会显示）
3. 共有的方法和属性


以 `__` 开头不以 `__` 结尾的属性是更加特殊的方法，调用方式也不同：


```python 
class MyDemoClass(object):
    def __init__(self):
        print("special.")

    def _get_name(self):
        print("_get_name is private method.")

    def get_value(self):
        print("get_value is public method.")

    def __get_type(self):
        print("__get_type is really special method.")
```


```python 
demo = MyDemoClass()

```


```python 
demo.get_value()
demo._get_name()
demo._MyDemoClass__get_type()
```

